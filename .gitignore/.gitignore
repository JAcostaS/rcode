#############################################################################

Input2 <- function(y,k)
{
  n=dim(y)[1]
  m=dim(y)[2]
  y5=y;
  k2=k;
  i=0;
  while(k>0)
  {
    y1=y5;
    y2=y5;
    y3=y5;
    y4=y5;
#    lm1=lm1_Image(y5[max(1,(n-k)/2-2*k+1):((n-k)/2),((m-k)/2+1):((m+k)/2)])
#    lm2=lm1_Image(t(y5[((n-k)/2+1):((n+k)/2),max(1,(m-k)/2-2*k+1):((m-k)/2)]))
#    lm3=lm1_Image(t(y5[((n-k)/2+1):((n+k)/2),min(m,(m+k)/2+2*k):((m+k)/2+1)]))
#    lm4=lm1_Image(y5[min(n,(n+k)/2+2*k+1):((n+k)/2+1),((m-k)/2):((m+k)/2)])
    
#    lm1=lm1_Image(y5[1:((n-k)/2),((m-k)/2+1):((m+k)/2)])
#    lm2=lm1_Image(t(y5[((n-k)/2+1):((n+k)/2),1:((m-k)/2)]))
#    lm3=lm1_Image(t(y5[((n-k)/2+1):((n+k)/2),m:((m+k)/2+1)]))
#    lm4=lm1_Image(y5[n:((n+k)/2+1),((m-k)/2):((m+k)/2)])
    
#    lm1=lm1_Image(y5[1:((n-k2)/2),((m-k2)/2+1):((m+k2)/2)])
#    lm2=lm1_Image(t(y5[((n-k2)/2+1):((n+k2)/2),1:((m-k2)/2)]))
#    lm3=lm1_Image(t(y5[((n-k2)/2+1):((n+k2)/2),m:((m+k2)/2+1)]))
#    lm4=lm1_Image(y5[n:((n+k2)/2+1),((m-k2)/2):((m+k2)/2)])
    
    lm1=lm1_Image(y5[max(1,(n-k2)/2-2*k2+1+i):((n-k2)/2+i),((m-k2)/2+1):((m+k2)/2)])
    lm2=lm1_Image(t(y5[((n-k2)/2+1):((n+k2)/2),max(1,(m-k2)/2-2*k2+1+i):((m-k2)/2+i)]))
    lm3=lm1_Image(t(y5[((n-k2)/2+1):((n+k2)/2),min(m,(m+k2)/2+2*k2-i):((m+k2)/2+1-i)]))
    lm4=lm1_Image(y5[min(n,(n+k2)/2+2*k2+1-i):((n+k2)/2+1-i),((m-k2)/2):((m+k2)/2)])
    
    
    coef1=lm1$coef
    coef2=lm2$coef
    coef3=lm3$coef
    coef4=lm4$coef
    for(j in 1:k)
    {
      y1[(n-k)/2+1,(m-k)/2+j] <- coef1[1] + coef1[2]*y1[(n-k)/2,(m-k)/2+j] + coef1[3]*y1[(n-k)/2+1,(m-k)/2+j-1] + coef1[4]*y1[(n-k)/2,(m-k)/2+j-1]
      y2[(n-k)/2+j,(m-k)/2+1] <- coef2[1] + coef2[2]*y2[(n-k)/2+j-1,(m-k)/2+1] + coef2[3]*y2[(n-k)/2+j,(m-k)/2] + coef2[4]*y2[(n-k)/2+j-1,(m-k)/2]
      y3[(n-k)/2+j,(m+k)/2] <- coef3[1] + coef3[2]*y3[(n-k)/2+j-1,(m+k)/2] + coef3[3]*y3[(n-k)/2+j,(m+k)/2+1] + coef3[4]*y3[(n-k)/2+j-1,(m+k)/2+1]
      y4[(n+k)/2,(m-k)/2+j] <- coef4[1] + coef4[2]*y4[(n+k)/2+1,(m-k)/2+j] + coef4[3]*y4[(n+k)/2,(m-k)/2+j-1] + coef4[4]*y4[(n+k)/2+1,(m-k)/2+j-1]
    }
    y5[(n-k)/2+1,((m-k)/2+1):((m+k)/2)] <- y1[(n-k)/2+1,((m-k)/2+1):((m+k)/2)]
    y5[((n-k)/2+1):((n+k)/2),(m-k)/2+1] <- y2[((n-k)/2+1):((n+k)/2),(m-k)/2+1]
    y5[((n-k)/2+1):((n+k)/2),(m+k)/2] <- y3[((n-k)/2+1):((n+k)/2),(m+k)/2]
    y5[(n+k)/2,((m-k)/2+1):((m+k)/2)] <- y4[(n+k)/2,((m-k)/2+1):((m+k)/2)]
    
    y5[(n-k)/2+1,(m-k)/2+1] <- mean( c(y1[(n-k)/2+1,(m-k)/2+1], y2[(n-k)/2+1,(m-k)/2+1] ))
    y5[(n-k)/2+1,(m+k)/2] <- mean( c(y1[(n-k)/2+1,(m+k)/2], y3[(n-k)/2+1,(m+k)/2] ))
    y5[(n+k)/2,(m-k)/2+1] <- mean( c(y2[(n+k)/2,(m-k)/2+1], y4[(n+k)/2,(m-k)/2+1] ))
    y5[(n+k)/2,(m+k)/2] <- mean( c(y3[(n+k)/2,(m+k)/2], y4[(n+k)/2,(m+k)/2] ))
    
    k=k-2
    
    print(k)
  }
  i=i+1
#  image(y5, col = gray(0:255 / 255), xaxt = "n", yaxt = "n")
  y5
}



#########################################################################

Input <- function(y,k)
{
  n=dim(y)[1]
  m=dim(y)[2]
  lm1=lm1_Image(y[1:((n-k)/2),1:((m-k)/2)])
  coeff=lm1$coef
  y1=y
  for(i in ((n-k)/2):((n+k)/2))
  {
    for(j in ((m-k)/2):((m+k)/2))
    {
      y1[i+1,j+1] <- coeff[1]+coeff[2]*y1[i,j+1]+coeff[3]*y1[i+1,j]+coeff[4]*y1[i,j]
    }
  }
#  image(y1, col = gray(0:255 / 255), xaxt = "n", yaxt = "n")
  y1
}


##########################################################################
################ lm de una imagen 3 covariables ##########################

lm1_Image=function(imagen)
{
  tam=dim(imagen)
#  Im=matrix(imagen, nrow=tam[1], ncol=tam[2],byrow=F)
  Im=as.matrix(imagen)
  Im1=Im[2:tam[1],2:tam[2]]
  Im11=Im[1:(tam[1]-1),2:tam[2]]
  Im12=Im[2:tam[1],1:(tam[2]-1)]
  Im13=Im[1:(tam[1]-1),1:(tam[2]-1)]
  
  lm_image=lm(c(Im1)~c(Im11)+c(Im12)+c(Im13))
  lm_image
}



#################################################################
Par<-function(x)
{
  ceiling(x/2)==x/2
}

#################################################################
index<-function(a,k,m)
{
  aux=c()
  if(Par(k)==FALSE)
  {
    for(i in 1:m)
    {
      mx=round(i*a/(m+1))
      aux=c(aux, (mx-(k+1)/2+1):(mx+(k+1)/2-1))
    }
  }else
  {
    for(i in 1:m)
    {
      mx=round(i*a/(m+1))
      aux=c(aux, (mx-k/2+1):(mx+k/2))
    }
  }
  aux
}

#################################################################

NAblock<- function(x, k, m)
{
  xrow <- nrow(x)
  xcol <- ncol(x)
  eps <- x
  if(length(m)==1){m=c(m,m)}
  rx=index(xrow,k,m[1])
  ry=index(xcol,k,m[2])
  print(c( length(rx), length(ry) ) )
  eps[rx,ry]<-1
  eps
}


#################################################################

hmapdirection <- function(x,y,r,l,name,name2)
{
 nc=dim(x)[2]
 nr=dim(x)[1]
 tt=min(nc,nr)
 hh1=seq(0,ceiling(tt/l), by=r)
 hh1=c(-hh1[length(hh1):2],hh1)
 hh2=seq(0,ceiling(tt/l), by=r)
 H=expand.grid(hh1,hh2)
 H<-H[H[,1]^2+H[,2]^2<=(tt/l)^2,]
 H3<-H
 H3[,1]<-(H[,1]+max(abs(H[,1]))+r)/r
 H3[,2]<-(H[,2]+r)/r

 aux <-  matrix(,ncol=max(H3[,2]) ,nrow=max(H3[,1]))
 print(dim(H)[1])
 for(k in 1:dim(H)[1])
 {
   aux[H3[k,1],H3[k,2]]=rhoh.c(x,y,hx=H[k,1],hy=H[k,2])
   print(c(k,aux[H3[k,1],H3[k,2]]))
 }
 write.table(aux, file = name2)
 jpeg(name, width = 640, height = 480)
   image.plot(x=hh1[c(-1,-length(hh1))], y=hh2[-length(hh2)], z=aux, col = gray(0:255/255),
            main="Codispersion Map", xlab="Spatial Lag X", ylab="Spatial Lag Y",
            xlim=c(min(hh1),max(hh1)), ylim=c(0,max(hh2)), zlim=c(0,1) )
   abline(h=0, lwd=2)
   xx=seq(min(hh1),max(hh1),length=1000000)
   yy=sqrt((tt/l)^2-xx^2)
   points(xx,yy,type="l",lwd=2)
 dev.off()
 aux
}

#################################################################

hmapdirection2 <- function(x,y,r,l)
{
 nc=dim(x)[2]
 nr=dim(x)[1]
 tt=min(nc,nr)
 hh1=seq(0,ceiling(tt/l), by=r)
 hh1=c(-hh1[length(hh1):2],hh1)
 hh2=seq(0,ceiling(tt/l), by=r)
 H=expand.grid(hh1,hh2)
 H<-H[H[,1]^2+H[,2]^2<=(tt/l)^2,]
 H3<-H
 H3[,1]<-(H[,1]+max(abs(H[,1]))+r)/r
 H3[,2]<-(H[,2]+r)/r

 aux <-  matrix(,ncol=max(H3[,2]) ,nrow=max(H3[,1]))
 print(dim(H)[1])
 for(k in 1:dim(H)[1])
 {
   aux[H3[k,1],H3[k,2]]=rhoh.c(x,y,hx=H[k,1],hy=H[k,2])
   print(c(k,aux[H3[k,1],H3[k,2]]))
 }
 image.plot(x=hh1[c(-1,-length(hh1))], y=hh2[-length(hh2)], z=aux, col = gray(0:255/255),
            main="Codispersion Map", xlab="Spatial Lag X", ylab="Spatial Lag Y",
            xlim=c(min(h1),max(h1)), ylim=c(0,max(h2))   )
 abline(h=0, lwd=2)
 xx=seq(min(hh1),max(hh1),length=1000000)
 yy=sqrt((tt/l)^2-xx^2)
 points(xx,yy,type="l",lwd=2)

 aux
}

#######################################################

direction2 <- function(x,y,r,l)
{
 nc=dim(x)[2]
 nr=dim(x)[1]
 tt=min(nc,nr)
 h1=seq(0,ceiling(tt/l), by=r)
 h1=c(-h1[length(h1):2],h1)
 h2=seq(0,ceiling(tt/l), by=r)
 H=expand.grid(h1,h2)
 H<-H[H[,1]^2+H[,2]^2<=(tt/l)^2,]
 print(dim(H)[1])
 H
}



#######################################################

direction <- function(x,y,r,l)
{
 ptm <- proc.time()
 nc=dim(x)[2]
 nr=dim(x)[1]
 tt=min(nc,nr)
 h1=seq(0,ceiling(tt/l), by=r)
 h1=c(-h1[length(h1):2],h1)
 h2=seq(0,ceiling(tt/l), by=r)
 H=expand.grid(h1,h2)
 H<-H[H[,1]^2+H[,2]^2<=(tt/l)^2,]
 print(dim(H)[1])
 proc.time() - ptm
}


#######################################################

NAcont2 <- function(x, epsilon, K)
   {
       xrow <- nrow(x)
       xcol <- ncol(x)
       bin <- rbinom(xrow * xcol, size = 1, prob = epsilon)
       eps <- matrix(bin, nrow = xrow, ncol = xcol)
       eps2 <- eps
       for(i in 1:xrow)
       {
	 for(j in 1:xcol)
	 {
	   if(eps[i,j]==1)
	   {
       for(k in 1:K)
	     {
	       a=round(runif(1,-1.5,1.5),0)
	       b=round(runif(1,-1.5,1.5),0)
         i=max(1,i+a)
	       j=max(1,j+b)
         i=min(i,xrow)
         j=min(j,xcol) 
         eps2[i,j]<-1
	     }
	    }
	  }
	}
       y <- matrix(xrow * xcol, nrow = xrow, ncol = xcol)
       y <- (1 - eps2) * x + eps2 
       y
  }


#######################################################

NAcont3 <- function(x, epsilon, K)
   {
    xrow <- nrow(x)
    xcol <- ncol(x)
    bin <- rbinom(xrow * xcol, size = 1, prob = epsilon)
    eps <- matrix(bin, nrow = xrow, ncol = xcol)
    eps2 <- eps
    for(i in 1:xrow)
       {
	      for(j in 1:xcol)
	      {
	       if(eps[i,j]==1)
	        {
           for(k in 1:K)
	          {
	            a=round(runif(1,-1.5,1.5),0)
	            b=round(runif(1,-1.5,1.5),0)
              i=max(1,i+a)
	            j=max(1,j+b)
              i=min(i,xrow)
              j=min(j,xcol) 
              eps2[i,j]<-1
	          }
	        }
	      }
	    }
       eps2[eps2==1]<-NA
       y <- matrix(xrow * xcol, nrow = xrow, ncol = xcol)
       y <- (1 - eps2) * x 
       y
             
}

#######################################################

saltnpepper <- function(x, epsilon)
{
  xrow <- nrow(x)
  xcol <- ncol(x)
  eps <- rbinom(xrow * xcol, size = 1, prob = epsilon)
  eps <- matrix(eps, nrow = xrow, ncol = xcol)
  
  xbar <- mean(x)
  xsd <- sd(x)
  
  noise <- rnorm(xrow * xcol, mean = xbar, sd = xsd)
  y <- (1 - eps) * x + eps * noise
  y <- ifelse(y > 1, 1, y)
  y <- ifelse(y < 0, 0, y)
  y
}




#######################################################

NAcont <- function(x, epsilon, k)
   {
       xrow <- nrow(x)
       xcol <- ncol(x)
       xrow <- nrow(x)
       xcol <- ncol(x)
       bin <- rbinom(xrow * xcol, size = 1, prob = epsilon)
       eps <- matrix(bin, nrow = xrow, ncol = xcol)
       eps2 <- eps
       for(j in 1:(xcol))
       {
         for(i in 1:(xrow))
         {
           if(eps[i,j]==1) eps2[max(1,(i-k)):min((i+k),xrow),max(1,(j-k)):min(xcol,(j+k))]<-1
         }
       }
       y <- matrix(xrow * xcol, nrow = xrow, ncol = xcol)
       y <- (1 - eps2) * x + eps2
       y
             
}


#######################################################

NACC <- function(x, epsilon)
{
  xrow <- nrow(x)
  xcol <- ncol(x)
  
  xpos<-round(runif(1,1,xrow))
  ypos<-round(runif(1,1,xcol))
  
  x[xpos,ypos]<-NA
  
  
  d=1
  repeat{
    
    for (i in 1:xrow){
      for (j in 1:xcol){
        if (sqrt((xpos-i)^2+(ypos-j)^2)<=d) x[i,j]=NA
      }
    }  
    
    d=d+1
    counter=length(which(is.na(x)))/(xrow*xcol)
    if (counter >=epsilon) break
    
  }
  #   image(x, col  = gray((0:32)/32))
  x
  
}

#################################################################

rhoh <- function(x,y,h1,h2)
{
 m=ncol(x)
 n=nrow(x)
 num=0
 den1=0
 den2=0
 if(h1>=0){
 for (i in 1:(n-h1)){
	for (j in 1:(m-h2)){
		num=num+(x[i+h1,j+h2]-x[i,j])*(y[i+h1,j+h2]-y[i,j])
		den1=den1+(x[i+h1,j+h2]-x[i,j])^2
		den2=den2+(y[i+h1,j+h2]-y[i,j])^2
	}
 }
 }else{
 for (i in (1-h1):n){
	for (j in 1:(m-h2)){
		num=num+(x[i+h1,j+h2]-x[i,j])*(y[i+h1,j+h2]-y[i,j])
		den1=den1+(x[i+h1,j+h2]-x[i,j])^2
		den2=den2+(y[i+h1,j+h2]-y[i,j])^2
	}
 } }
 num/sqrt(den1*den2)	
}

#################################################################

rhoh_xy <- function(x,y,h1,h2)
{
  xh=c(Ah(x,h1,h2))
  yh=c(Ah(y,h1,h2))
  cor(xh,yh)
  (sum(xh*yh))/(sqrt(sum(xh^2)*sum(yh^2)))
}


#################################################################

Ah <- function(x,h1,h2)
{
  m=ncol(x)
  n=nrow(x)
  xh=matrix(0,nc=m,nr=n)
  if(h1>=0)
  {
  for(i in 1:(n-h1))
  {
    for(j in 1:(m-h2))
    { 
      xh[i,j]=x[i+h1,j+h2]-x[i,j]
    }
  }
  aux=xh[1:(n-h1),1:(m-h2)]
  }else{
  for(i in (1-h1):n)
  {
    for(j in 1:(m-h2))
    { 
      xh[i,j]=x[i+h1,j+h2]-x[i,j]
    }
  }
  aux=xh[(1-h1):n,1:(m-h2)]  
  }
  aux
}


#################################################################

Grises <- function(x)
{
  a <- dim(x)[1]
  b <- dim(x)[2]
  
  t((x[,,1]+x[,,2]+x[,,3])/3)[,a:1]
}

             
